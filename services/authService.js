
const bcrypt = require('bcrypt');
const saltRounds = 5; // ‡∏¢‡∏¥‡πà‡∏á‡∏°‡∏≤‡∏Å‡∏¢‡∏¥‡πà‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢ ‡πÅ‡∏ï‡πà‡∏¢‡∏¥‡πà‡∏á‡∏ä‡πâ‡∏≤
const User = require('../models/User');
const { getNextSequenceValue } = require('../utils/idGenerator');

async function hashPasswordAndSave(plainTextPassword) {

    if (!plainTextPassword || typeof plainTextPassword !== 'string' || plainTextPassword.length === 0) {
        // üí° Business Logic: ‡πÇ‡∏¢‡∏ô Error ‡∏ó‡∏µ‡πà‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡πÑ‡∏î‡πâ‡∏î‡∏µ‡∏Å‡∏ß‡πà‡∏≤
        throw new Error('Invalid or empty password provided for hashing.');
    }
    const passwordHash = await bcrypt.hash(plainTextPassword, saltRounds);

    return passwordHash;
}


// // compare ( Input password === Hash password ) 
// const mockComparePassword = (inputPassword, hashedPassword) => {
//     const expectedHash = `Hashed_${inputPassword}_ABC`;
//     return expectedHash === hashedPassword;
// };

// Gen token
//const mockGenerateToken = (userId) => `MOCK_JWT_TOKEN_${userId}_${Date.now()}`;

// Get all users
exports.getUsers = async () => {
    return await User.find();
};

//Get user by id
exports.getUserById = async (UserId) => {

    const queryId = Number(UserId); 
        
    const user = await User.findOne({ acc_id: queryId }); 
    
    if (!user) {
        // üí° Best Practice: ‡πÇ‡∏¢‡∏ô Error ‡∏ó‡∏µ‡πà‡∏°‡∏µ Status Code 404
        const error = new Error(`User with ID ${UserId} not found.`);
        error.statusCode = 404; // HTTP Not Found
        throw error; 
    }

    return user;
};

// // Register
exports.registerUser = async (
    username, 
    email, 
    password, 
    firstname, 
    lastname, 
    phone, 
    address, 
    acc_coin = 10000// üîë ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤ Default ‡πÉ‡∏ô Service Layer
) => {
   
    const passwordHash = await hashPasswordAndSave(password);

    const newAccId = await getNextSequenceValue('user');
    
    // 4. SAVE NEW USER: ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏´‡∏°‡πà‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    const newUser = await saveNewUser({ 
        acc_id: newAccId,
        username: username.trim(), 
        email: email.trim(), 
        passwordHash, // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà Hash ‡πÅ‡∏•‡πâ‡∏ß
        firstname: firstname.trim(), 
        lastname: lastname.trim(), 
        phone: phone.trim(), 
        address: address.trim(),
        acc_coin
    });
    return newUser;
};

// // Login
// exports.loginUser = async (username, password) => {
    
//     //check username
//     //console.log('password',password)
//     const user = await findUserByUsername(username); 
//     if (!user) {
//         const error = new Error('Invalid credentials.'); // 401 Unauthorized
//         error.statusCode = 401; 
//         throw error;
//     }
//     console.log(user.passwordHash)

//     // Check: Compare Password
//     const isMatch = await bcrypt.compare(password, user.passwordHash);
//     //console.log(isMatch)

//     if (!isMatch) {
//         const error = new Error('Invalid credentials.'); 
//         error.statusCode = 401; 
//         throw error;
//     }

//     // 3. Token Generation
//     const token = mockGenerateToken(user.id);
//     //console.log(`token : `, token)

//     // 4. Return (Strip Hash)
//     const { passwordHash, ...userWithoutHash } = user;
    
//     return {
//         token,
//         user: userWithoutHash,
//     };
// };

// const allowedUpdates = ['username', 'firstname', 'lastname', 'email', 'phone', 'address'];


// exports.updateUserProfile = async(targetUserId, updates) => {
    
//     const rawUsers = await getAllUsersFromDB(); 
//     const user = rawUsers.find(p => p.id === parseInt(targetUserId));
//     console.log(user)
    
//     if (!user) {
//         console.log(45)
//         // üí° Business Logic: ‡∏™‡πà‡∏á Error ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏´‡πâ Controller ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Status Code (404)
//         throw new Error('User not found.'); 
//     }

//     // Step 2: Whitelisting - ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï
//     const finalUpdates = {};
//     Object.keys(updates).forEach(key => {
//         if (allowedUpdates.includes(key) && updates[key] !== undefined) {
//             finalUpdates[key] = updates[key];
//         } 
//     });

//     // Step 3: Business Logic - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Email ‡∏ã‡πâ‡∏≥
//     if (finalUpdates.email && finalUpdates.email !== user.email) {
//         const existingUser = await findUserByField('email', finalUpdates.email);
        
//         // üí° Logic: ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏ô‡∏≠‡∏∑‡πà‡∏ô (id ‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô) ‡πÉ‡∏ä‡πâ‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏ô‡∏µ‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
//         if (existingUser && existingUser.id !== targetUserId) { 
//             // ‡∏™‡πà‡∏á Error ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏´‡πâ Controller ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Status Code (400)
//             throw new Error('This email is already in use by another user.');
//         }
//     }
//     // üîë Step 4: ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å Repository ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Persistence (‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Mock File)
//     const updatedUser = await updateUser(targetUserId, finalUpdates);
//     console.log(updatedUser)
//     // Step 5: Business Logic - ‡∏ã‡πà‡∏≠‡∏ô‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤
//     if (updatedUser) {
//         updatedUser.password = undefined; 
//     }

//     // ‚úÖ Return ‡∏Ñ‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô Business Logic ‡πÅ‡∏•‡∏∞ Persistence ‡πÅ‡∏•‡πâ‡∏ß
//     return updatedUser;
// };



const saveNewUser = async (userData) => {
    // üí° Tech Stack: ‡πÉ‡∏ä‡πâ Mongoose Model ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Document ‡πÉ‡∏´‡∏°‡πà
    const newUser = new User({
        acc_id: userData.acc_id,
        acc_username: userData.username,
        acc_email: userData.email,
        acc_password: userData.passwordHash, // Mongoose ‡∏à‡∏∞‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ select: false ‡πÉ‡∏´‡πâ‡πÄ‡∏≠‡∏á
        acc_firstname: userData.firstname,
        acc_lastname: userData.lastname,
        acc_phone: userData.phone,
        acc_address: userData.address,
        acc_coin: userData.acc_coin
        // ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á save acc_createdate ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ Mongoose ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏î‡πâ‡∏ß‡∏¢ timestamps: true
    });

    await newUser.save();
    return newUser;
};